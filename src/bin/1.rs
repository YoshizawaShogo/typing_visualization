// Generated by chatgpt

// src/main.rs
use libc::{
    ECHO, FD_SET, FD_ZERO, ICANON, ICRNL, IEXTEN, INLCR, ISIG, ISTRIP, IXANY, IXON, OPOST, TCSANOW,
    VMIN, VTIME, c_int, fd_set, read, select, tcgetattr, tcsetattr, termios, timeval,
};
use std::io::{self, Write};
use std::mem::MaybeUninit;
use std::os::fd::RawFd;

const STDIN_FD: RawFd = 0;
const CTRL_D: u8 = 0x04;
const VIS_COL: usize = 20; // 1始まりの20桁目から可視化

struct RawMode {
    fd: RawFd,
    orig: termios,
}
impl RawMode {
    fn new(fd: RawFd) -> io::Result<Self> {
        unsafe {
            let mut t = MaybeUninit::<termios>::uninit();
            if tcgetattr(fd, t.as_mut_ptr()) != 0 {
                return Err(io::Error::last_os_error());
            }
            let orig = t.assume_init();
            let mut raw = orig;

            raw.c_iflag &= !(IXON | IXANY | ICRNL | INLCR | ISTRIP);
            raw.c_oflag &= !(OPOST);
            raw.c_lflag &= !(ICANON | ECHO | IEXTEN | ISIG);
            raw.c_cc[VMIN] = 1;
            raw.c_cc[VTIME] = 0;

            if tcsetattr(fd, TCSANOW, &raw) != 0 {
                return Err(io::Error::last_os_error());
            }
            Ok(Self { fd, orig })
        }
    }
}
impl Drop for RawMode {
    fn drop(&mut self) {
        unsafe {
            let _ = tcsetattr(self.fd, TCSANOW, &self.orig);
        }
    }
}

fn drain_burst(first: u8, timeout_ms: i64) -> io::Result<Vec<u8>> {
    let mut buf = vec![first];
    loop {
        let mut rfds = unsafe { std::mem::zeroed::<fd_set>() };
        unsafe {
            FD_ZERO(&mut rfds);
            FD_SET(STDIN_FD as c_int, &mut rfds);
        }
        let mut tv = timeval {
            tv_sec: (timeout_ms / 1000) as _,
            tv_usec: ((timeout_ms % 1000) * 1000) as _,
        };
        let ready = unsafe {
            select(
                1,
                &mut rfds,
                std::ptr::null_mut(),
                std::ptr::null_mut(),
                &mut tv,
            )
        };
        if ready < 0 {
            return Err(io::Error::last_os_error());
        } else if ready == 0 {
            break;
        } else {
            let mut byte: u8 = 0;
            let n = unsafe { read(STDIN_FD, &mut byte as *mut u8 as *mut _, 1) };
            if n < 0 {
                return Err(io::Error::last_os_error());
            } else if n == 0 {
                break;
            } else {
                if byte == CTRL_D {
                    buf.push(byte);
                    break;
                }
                buf.push(byte);
            }
        }
    }
    Ok(buf)
}

fn vis_byte(b: u8) -> String {
    match b {
        0x00 => "<NUL>".into(),
        0x07 => "<BEL>".into(),
        0x08 => "<BS>".into(),
        0x09 => "\\t".into(),
        0x0A => "\\n".into(),
        0x0D => "\\r".into(),
        0x1B => "<ESC>".into(),
        0x7F => "<DEL>".into(),
        0x20..=0x7E => (b as char).to_string(), // 可視ASCIIはそのまま
        0x01..=0x1A => format!("^{}", (b + 0x40) as char), // ^A..^Z
        0x1C..=0x1F => match b {
            0x1C => "^\\".into(), // FS
            0x1D => "^]".into(),  // GS
            0x1E => "^^".into(),  // RS
            0x1F => "^_".into(),  // US
            _ => unreachable!(),
        },
        _ => format!("0x{:02X}", b), // 非ASCIIは16進
    }
}

fn main() -> io::Result<()> {
    let _raw = RawMode::new(STDIN_FD)?;
    let mut out = io::BufWriter::new(io::stdout().lock());
    let timeout_ms = 10;

    loop {
        let mut b: u8 = 0;
        let n = unsafe { read(STDIN_FD, &mut b as *mut u8 as *mut _, 1) };
        if n < 0 {
            return Err(io::Error::last_os_error());
        } else if n == 0 {
            break;
        }
        if b == CTRL_D {
            break;
        }

        let burst = drain_burst(b, timeout_ms)?;

        // 左側: u8十進数（例: "27 91 65"）
        let left = burst
            .iter()
            .map(|x| x.to_string())
            .collect::<Vec<_>>()
            .join(" ");

        // 右側: 可視化（例: "<ESC> [ A"）
        let right = burst
            .iter()
            .map(|&x| vis_byte(x))
            .collect::<Vec<_>>()
            .join(" ");

        // パディングして20桁目から右側を開始
        // VIS_COL は1始まり。左側の文字数はASCIIのみなので=表示幅。
        let pad = VIS_COL.saturating_sub(left.chars().count() + 1);
        write!(
            out,
            "{left} {spaces:pad$}| {right}\r\n",
            spaces = " ",
            pad = pad
        )?;
        out.flush()?;
    }

    Ok(())
}
